# -*- coding: utf-8 -*-
"""MinHash.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o45eSCszxQ9aBFDGAGi2QYhIuKWwSw_I

created by : Abhinav Jha
"""

import re
import os
import random
import time
import binascii
import sys

fstart = time.time()
numHashes = 10

numDocs = 100
numElems = int(numDocs * (numDocs - 1) / 2)


jacard = [0 for j in range(numElems)]
minHashSim = [0 for i in range(numElems)]

dataFile = './data/docs_'+str(numDocs) + '.train'
plagFile = './data/docs_'+str(numDocs) +'.plag'


#returns index of triangular matrix
def get_index(i,j):
    #k = i*numDocs + j
    k = int(i * (numDocs - (i + 1) / 2.0) + j - i) - 1
    
    return k

doc_file = open(dataFile,'r')
doc = doc_file.read()

doc = list(doc.split('\n'))


doc = doc[:numDocs]


plagiarisms = {}

f = open(plagFile,'r')
for line in f:
    if line[-1] == '\n':
        line = line[0:-1]
    
    l = line.split(' ')
    plagiarisms[l[0]] = l[1]
    plagiarisms[l[1]] = l[0]

def generate_shingles(s, n=3):
    tokens = [token for token in s.split(" ")]
    ngrams = zip(*[tokens[i:] for i in range(n)])
    return ["".join(ngram) for ngram in ngrams]

print('Creating Shingles')

c_shingleID = 0
documentShingleSets = {}

doc_names = []
n_shingles = 0

shingle_Set = set()

#chapter 6 in book frequent item (traingular matrix implementation)

for i in range(len(doc)):

    row = doc[i].split(' ',1)
    
    shingles = generate_shingles(row[1])
    shingle_hash = set()
#     words = row[1].split(' ')
    
    for shingle in shingles:
        h = binascii.crc32(shingle.encode()) & 0xffffffff

        shingle_hash.add(h)
        shingle_Set.add(h)
    
    doc_names.append(row[0])
    
    n_shingles += len(shingles)
    
    documentShingleSets[row[0]] = shingle_hash
    
    
    
    
print(n_shingles,len(shingle_Set))
print('Average shingles : ',n_shingles/numDocs)
# print(doc_names)

start = time.time()

for i in range(numDocs):
#     l = []
    for j in range(i+1,numDocs):
        s1 = documentShingleSets[doc_names[i]]
        s2 = documentShingleSets[doc_names[j]]
#         l.append(len(s1&s2)/(len(s1|s2)))

        jacard[(int)(get_index(i,j))] = (len(s1&s2)/len(s1|s2))
    
finish = time.time()
print('Time taken to create Jacard : ',finish-start)
#for using the triangular matrix
# k = (i-1)(n-i/2) + j- i

#Min Hashing
maxShingleID = pow(2,32)-1

mod = 4294967311


#(ax+b)%c

#generating the random coefficients



def generate_coef(k):
    
    i = 0
    l = []
    while i<k:
        x = random.randint(0,maxShingleID)
        while x in l:
            x = random.randint(0,maxShingleID)
            
        l.append(x)
        i += 1
        
    return l

A = generate_coef(numHashes)
B = generate_coef(numHashes)

signatures = []
start = time.time()
for doc in doc_names:
    shingles = documentShingleSets[doc]
    
    sign = []
    
    for i in range(numHashes):
        m = sys.maxsize
        
        for shingle in shingles:
            h = ((A[i]*shingle)%mod + B[i])%mod
            
            if m>h:
                m = h
        sign.append(m)
    signatures.append(sign)
    
finish = time.time()
print('Time taken to create signatures : ',finish-start)

start = time.time()
for i in range(numDocs):
    sign1 = signatures[i]
    for j in range(i+1,numDocs):
        sign2 = signatures[j]
        c = 0
        for k in range(len(sign2)):
            if sign1[k] == sign2[k]:
                c += 1
                
        
        
        minHashSim[int(get_index(i,j))] = c / numHashes

finish = time.time()

print('Time taken to generate MinHash : ',finish-fstart)
# print(minHashSim)

true_pos = 0
false_pos = 0
threshold = 0.5


print('Similar documents : \n DOC1 DOC2 MINHASH JACARD')
for i in range(numDocs):
    for j in range(i+1,numDocs):
        if minHashSim[int(get_index(i,j))] > threshold:
            print(doc_names[i],doc_names[j],minHashSim[int(get_index(i,j))],jacard[int(get_index(i,j))])
            
            if doc_names[i] in plagiarisms and plagiarisms[doc_names[i]] == doc_names[j]:
                true_pos += 1
            else:
                false_pos += 1
                
                
finish = time.time()              
print('True positive : ',true_pos,' / ',len(plagiarisms)//2)
print('False positive : ',false_pos)

print('Time taken to run the complete code : ',finish-fstart)
