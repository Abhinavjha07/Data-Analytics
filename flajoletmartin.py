# -*- coding: utf-8 -*-
"""FlajoletMartin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ra1WbIr_eg7ACzVjhm7yK73YgpNA2Vr6
"""

!git clone https://github.com/dipsankarb/streaming.git

"""# Flajolet Martin Algorithm for counting Distinct Elements 

In this implementation we are going to implement the FM algorithm foounting the number of unique quotes from the provided data file (memes). You have to implement the following:

First define a function to count the number of trailing zeroes in tha binary representation.
"""

!pip install mmh3
import mmh3
import statistics
import math

data_path = '/content/streaming/meme/meme.txt'
data = []
with open(data_path,'r') as f:
    file_data = f.read()
    file_data = file_data.split('\n')

data = []
for line in file_data:
    l = line.split('\t',1)
    data.append(l[1])


print(len(data))
def count_trailing_zeroes(n):
    return len(n)-len(n.rstrip('0'))

"""Now input the file memes.txt that is provided in the /meme directory

Initialize two arrays one for storing the different hashed values (binary) and another for storing the trailing zeroes.

For every line in the file do the following:
1. Use murmur hash to hash the line to a binary format using 10 seeds (varying from 1 to 10)
     1. for (s in range(10))
           binary[s] = format(abs(mmh3.hash(line, seed))), '032b')
     2. for every binary[s] call count_trailing_zeroes() to find the number of trailing zeroes and and store in trails[]

Now create two groups of hashes (5 each). In each group calculate the expected number of disctinct element using the fact that it is with high probability $2^R$

Take average of medians of group wise results and show result
"""

num_hashes = 10
trails = [[] for i in range(num_hashes)]

max_trail = []
for i in range(num_hashes):
    for meme in data:
        s = format(abs(mmh3.hash(meme,i)),'032b')
        # print(s,count_trailing_zeroes(s))
        trails[i].append(count_trailing_zeroes(s))

    max_trail.append(max(trails[i]))
print(max_trail)
n_groups = 2
x = num_hashes//n_groups
groups = []
for i in range(n_groups):
    z = i*x
    # print(max_trail[z:z+x])
    groups.append(int(statistics.median(max_trail[z:z+x])))

x = int(statistics.mean(groups))
ans = 2**x
groundTruth = len(set(data))
print('Group-wise result : ',groups)
print('Average of median : ',x)
print('Ground Truth : ',groundTruth)
print('Expected value : ',ans)

print('Error : ',(groundTruth-ans)/groundTruth * 100,'%')